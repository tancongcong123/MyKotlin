类加载机制
    类通过ClassLoader的loadClass方法加载到内存中
    ClassLoader的类型
        Android中ClassLoader分为系统类加载器和自定义类加载器
        系统类加载器主要包括三种BootClassLoader、PathClassLoader、DexClassLoader：
            BootClassLoader：主要用来加载framework的class文件，他在zygote进程启动开始时，在Zygote.main()中执行资源预加载，此时会单例创建BootClassLoader对象
            BaseDexClassLoader：PathClassLoader和DexClassLoader的父类，主要的执行逻辑和文件的处理都在其中
            DexClassLoader：可以加在dex文件以及包含dex的压缩文件（apk和jar），不管加载哪种文件，最终都是加载dex文件
            PathClassLoader：负责加载系统和apk中的类，context.getClassLoader获取的就是PathClassLoader的实例，App就是默认用PathClassLoader来加载类的
    ClassLoader的加载过程
        双亲委托：首先检查类是否被加载过，没有就委托父类加载器进行查找，这样一次进行递归，直至最顶层的ClassLoader，如果最顶层找到了直接返回，否则继续向下调用自身的findClass方法，找到了直接返回，否则最终会交给调用者自身去查找
            优点 1 避免重复加载 2 更加安全 例如双亲委托模式使得系统的String类在虚拟机启动时就加载了，也就无法使用自定义的String类代替系统的String类
Java虚拟机的运行时内存模型
    java内存模型，往往指的是java程序在运行时内存的模型，而Java代码运行在java虚拟机上，所以java内存模型也就指Java虚拟机的运行时内存模型
    运行时内存划分为：
        [方法区（method area）]线程共享
            存放已经被java虚拟机加载的类的结构信息，包含运行时常量、字段和方法信息、静态变量等数据
            存在OutOfMemoryError
            [常量池] 用于存放编译器生成的各种字面量和符号引用。运行时常量池是MA的一部分
        [堆（heap）]线程共享
            用来存放对象实例，几乎所有的对象实例都分配在这里，在虚拟机栈中分配的只是引用，这些引用会指向堆中真正存储的对象
            存在OutOfMemoryError
        [程序计数器] 线程私有
            记录线程代码执行到的位置，及保存正在执行的字节码指令地址，如果是native方法则为空，没有OutOfMemoryError情况
        [虚拟机栈（VM stack）]线程私有
            存储线程中Java方法调用的状态，包括局部变量、参数、返回值以及运算的中间结果等。一个java虚拟机包含多个栈帧，一个栈帧用来存储局部变量、操作数栈、动态链接、方法出口等信息，
            当线程调用一个java方法时虚拟机就压入一个新的栈帧到该线程的java虚拟机栈中，当该方法执行完，这个栈帧就从java虚拟机栈中弹出，我们平时所说的栈内存就是指虚拟机栈
            存在StackOverFlowError、OutOfMemoryError
        [本地方法栈（native method stack）]线程私有
            作用同虚拟机栈一样，只不过是为native方法服务的
            存在StackOverFlowError、OutOfMemoryError
        GC主要针对java堆内存进行管理和回收
垃圾标记算法
    GC主要做两个工作：1内存的划分和分配 2垃圾回收
    GC采用分代收集算法来回收垃圾，回收前需要先标记出那些是垃圾，目前主要有两种标记算法：
    [引用计数算法]
        每个对象都有一个引用计数器，当对象被引用的时候它的计数器就加1，引用失效就减1，当引用器中数值为0的时候，表示该对象成了垃圾
        目前主流java虚拟机没有使用引用计数算法来为垃圾标记，只要是因为它不能解决对象之间相互循环引用的问题
        优点：引用计数收集器可以很快执行，对程序需要不被长时间打断的实时环境比较有利
    [根搜索算法]
        选定一些对象为GC Roots并组成根对象集合，然后以这些根对象为起点向下搜索，如果目标和GC Root是连接的则称该对象时可达的，否则为不可达即为可回收对象
        可作为GC Roots的对象主要有以下几种：
            虚拟机栈中正在使用的引用
            本地方法栈中JNI引用的对象
            方法区中运行时常量池引用的对象
            方法区中静态属性引用的对象
            运行中的线程
            由引导类加载器加载的对象
            GC控制的对象
        虽然解决了对象相互引用而无法释放的问题，但是跟搜索算法会到来新的问题即：内存泄漏
            堆内存中的长生命周期对象持有短生命周期的对象引用，尽管短生命周期对象已经不再需要，但也无法被回收，这就是内存泄漏的根本原因
            内存泄漏会导致内存慢慢变少，程序慢慢变卡最终导致内存溢出oom
        当对象经过可达性分析之后发现其不可达，那么它会被第一次标记并经历一次筛选，这个对象的finalize方法会被执行，如果对象没有覆盖finalize方法或者已经执行过了，虚拟机也不会去执行finalize方法了，会直接被回收
    ps:GC过程和对象的引用类型是密切相关的
        [Java中的引用类型] 
            强引用 创建一个新的对象就是创建一个强引用对象，一个对象具有强引用，是不会被回收的
            软引用 SoftReference一个对象只具有软引用，当内存不够的时候会回收这些对象
            弱引用 WeakReference垃圾收集器一旦发现只有弱引用的对象不管内存是否足够都会回收它
            虚引用 PhantomReference对象只有虚引用就和没有任何引用一样，任何时候都可能被回收，只具有虚引用的对象被回收的时候会收到一个系统通知，这是虚引用的主要作用
垃圾收集算法
    [标记-清除算法] 分为两个阶段：1标记出可回收的对象 2回收被标记的对象占用的空间
        不会移动对象，直接回收对象，会造成内存碎片
    [复制算法] 把内存划分为两个相等的区域，每次只使用其中一个区域，把存活的对象复制到另外一个区域，然后清理当前区域内存
        实现简单、运行高效，但是浪费空间，对象存活率高的时候会进行较多的复制操作效率会变低
    [标记压缩算法] 标记过程和标记清除算法一致，存活的对象往一端移动，然后对边界以外的内存进行回收
        解决了标记清楚算法的内存碎片华问题，被广泛用于老年代中，但是它也引起了额外的开销来保存迁移地址，需要遍历多次堆内存等
    [分代收集算法] 主流虚拟机的垃圾收集器都采用分代收集算法
        新生代 新建的对象=>复制算法
        老年代 存放新生代中经过多次垃圾回收仍然存在的对象=>标记压缩算法
Android 虚拟机
    [Android使用的虚拟机]
        Dalvik
        ART ART有多个不同的GC方案，这些方案含括运行不同的垃圾回收器
    [引起GC的原因]
    [垃圾收集]
常见的内存问题
    内存泄漏 
    内存抖动 短时间内有大量的对象被创建或者回收，伴随着频繁的GC，即为内存抖动，会造成UI卡顿
常见的内存泄漏场景